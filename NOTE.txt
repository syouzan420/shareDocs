## 操画製作について

平成7年9月26日[23:23]
毎日最低10分 ゲーム製作の時間をつくることにした

どんな操画にするのか

9月27日[20:39]
術式で戰ふゲーム
CPU もしくは 對人戰

---

 +----------------+
 |+      p2       |
 |+               |
 |+     +++       |
 |      +++       |
 |       |        |
 |                |
 |                |
 |                |
 |       |        |
 |      +++       |
 |      +-+      +|
 |               +|
 |       p1      +|
 +----------------+
[20:55]
術式として何を使ふか


9月28日 [20:27]
ヲシテがいいと思ふ
プレイヤーキャラの周囲をタップすることで
キャラの移動・回転

ヲシテの母音を描くことで 術式が發動し始める

術式によってエネルギー(氣)の消費が異なる

氣は時間の経過によって回復する

何を實装するか

[20:44]

画面のタッチからヲシテ文字を検出する

9/29 [11:52]

Main.hs
  onEvent ce TouchStart $ \(TouchData {}) -> do
    readIORef state >>= tcStart >>= writeIORef state
  onEvent ce TouchEnd $ \(TouchData {}) -> do
    readIORef state >>= touchIsTrue >>= writeIORef state

>>>

  onEvent ce TouchStart $ \(TouchData a b c) -> do
    mapM_ showTouch [a,b,c] 
    readIORef state >>= tcStart >>= writeIORef state
  onEvent ce TouchEnd $ \(TouchData a b c) -> do
    readIORef state >>= touchIsTrue >>= writeIORef state

+++
import Control.Monad.IO.Class (MonadIO,liftIO)

showTouch :: MonadIO m => [Touch] -> m () 
showTouch [] = return ()
showTouch (Touch idn tar pag cli scr:xs) = do
  let s = "idintifier:" ++ show idn ++ " target:" ++ " " ++ 
          " pageCoords:" ++ show pag ++ " clientCoords:" ++ show cli ++ 
          " screenCoords:" ++ show scr
  liftIO $ putStrLn s  
  showTouch xs

このやうにして タッチ機能を検証していかうと思ふ
どのやうにタッチしたら どんな數値が出てくるのか確認した上で
文字認識のコードを考えるためだ

ディスクトップでは検証できない(マウスでクリックしてもタッチとはみなされない)

タブレットでテストすることにする

githubに新らしいリポジトリをつくらうと思ふ
名前はどうしやう

ここのフォルダ名は yuto にしてゐるが
一應ゲームをどんな風にするか ある程度決まったので ゲームの名前を決めやう

ShooPin (シューピン) はどうか？

画面をシュッシュ ピンピンして戰ふだけの 分かりやすいゲームにしたい 
物理攻撃的なものは 最も直感的な操作で實現できるやうにし
術を使ふときには 画面上に文字を描くやうな動作で實現する
術攻撃は物理攻撃の10倍くらゐの威力を持ち 防御術は物理攻撃をほとんど
防げるやうにすれば バランス的によいのではないか
何故かといふと 物理攻撃は直感的に短時間でポコポコできるのに對し 
術式は画面に文字を描くから 動作に時間がかかる  
その間に物理攻撃を受けても それ以上の効果が期待できなくては
面白くないだらう

[12:44]
gitリポジトリ spをつくった
ゲーム名は 今のところ ShooPing (シューピン) としておく
シューティングが shooting なので ちょっとシャレていておもしろいかも知れない

[13:12]
タブレットの方でテストしてみた
gitリポジトリに Images や Audio を入れてゐなかったりしてうまく起動しなかった
Main.js css などもリポジトリに含め ブラウザで動作できるやうにした
エラーが出たのでコードを確認し改善した

9/30 [23:46]
タッチムーブの動きをタブレットでテストした
ARROWS TABLET Q507
イオナ
タブレットの呼び名にしやう
イオナはOSを nixos 25.05 にアップグレードした
skkが動くのは本當にうれしかった
タッチの座標は client pos を使へばよいと思ふ
ちなみに このディスクトップは 本當に長くお世話になってゐる
ムサシといふ名前をつけてゐたが nixOSなどを入れてゐるとき あまり意識してゐなかった
スマホがミクで タブレットがイオナなので この子も まう少し可愛い名前で呼びたい
EPSON Endeavor
Endeavor は 努力といふ意味だ
強い探求も含む感じがする
男っぽい響きだが もっと女性的な意味合ひはないだらうか
やってみること 探し續けること
Eva エヴァ イヴ エマ
母のごとくに 抱擁感のある名前がいい
あまり關係ないかもしれないが 「風子」といふのはどうか
「ふうこ」だ
なんとなく呼びやすくて いいかもしれない
ふうこ みく いおな
なかなか良い姉妹なのではないだらうか
キーボードは 今たたいてゐるのは 「クロ」
まう一つの 無地のやつは「マックン」
「マックン」なんて言ったら mac コンピュータと間違へられさうだが
どうせ 人には公言しないだらうし マックンでいいと思ふ
なんとなくキーボードは男性的な感じがするから 男っぽい名前にした
「ミク」と「マックン」 「イオナ」と「マックン」 「フウコ」と「クロ」の組み合はせだ

10/1 [9:57]

Main.hs に次の函數を追加

getCoords :: [Touch] -> [(Int,Int)]
getCoords = map (\(Touch _ _ _ cli _) -> cli)

addCoords :: [Touch] -> State -> State
addCoords tcs st = st{tccs=tccs st++[getCoords tcs]}

delCoords :: State -> State
delCoords st = st{tccs=[]}

showCoords :: MonadIO m => State -> m State
showCoords st = liftIO $ print (tccs st) >> return st

showTouch2 :: MonadIO m => [Touch] -> m ()
showTouch2 tcs = liftIO $ print (getCoords tcs)

次の函數を變更

  onEvent ce TouchStart $ \(TouchData a _ _) -> do
    showTouch2 a 
    readIORef state >>= tcStart >>= writeIORef state . delCoords
  onEvent ce TouchMove $ \ (TouchData a _ _) -> do
    showTouch2 a
    readIORef state >>= writeIORef state . addCoords a
  onEvent ce TouchEnd $ \(TouchData {}) -> do
    readIORef state >>= showCoords >>= touchIsTrue >>= writeIORef state
    setTimer (Once 100) $ readIORef state >>= tcEnd >>= writeIORef state
    return ()

まづ 表示させるものを タッチした場所の座標に限定した
また タッチし終えたときに それまでタッチした座標の一覧を表示する
おそらく文字認識は このデータと時間データによって決定できると思ふ
これからイオナでテストしてみる

[12:20]

[[(211,502)],[(208,502)],[(205,501)],[(202,500)],[(198,499)],[(194,498)],[(189,496)],[(183,493)],[(178,491)],[(174,488)],[(169,485)],[(165,482)],[(159,479)],[(154,475)],[(149,471)],[(146,466)],[(144,462)],[(141,457)],[(140,452)],[(138,446)],[(137,440)],[(137,435)],[(137,429)],[(137,422)],[(138,415)],[(139,407)],[(141,399)],[(143,392)],[(145,384)],[(148,377)],[(150,370)],[(153,364)],[(157,359)],[(161,354)],[(164,349)],[(168,346)],[(172,343)],[(176,340)],[(180,339)],[(185,338)],[(189,338)],[(195,338)],[(200,337)],[(205,337)],[(210,338)],[(215,339)],[(220,341)],[(225,343)],[(231,346)],[(236,349)],[(242,353)],[(247,357)],[(253,362)],[(259,368)],[(264,374)],[(269,380)],[(274,388)],[(277,394)],[(281,402)],[(284,410)],[(286,418)],[(287,426)],[(288,433)],[(288,441)],[(288,448)],[(287,455)],[(285,462)],[(282,468)],[(279,474)],[(275,480)],[(272,486)],[(269,492)],[(265,497)],[(260,502)],[(256,506)],[(251,509)],[(246,511)],[(241,514)],[(235,516)],[(229,517)],[(223,517)],[(216,517)],[(209,515)],[(202,513)],[(195,511)],[(188,508)],[(182,504)],[(178,498)],[(174,491)],[(171,483)]]

イオナで円を描いたときのデータ
もしかしたら 時間は關係なく かういったデータと文字を結びつけられるかもしれない

10/3 [10:07]

イオナはタブレットであり ブラウザ上で實行させてゐるので タッチをしてゐると
スクロールしやうとしたり 拡大・縮小しやうとしたりする

やはり スマホ實機でテストする必要があると思つた

そこで USBデバッグをつかひ ミクにこのアプリを導入して フウコ(PC)側でデバッグ情報を見るといふやり方があることを知ったので それをやってみたい 

そのためにまづ Monaca で ShooPing をアプリ化し ミクに入れなくてはならない

[10:28]

Monaca で デバッグビルドをしてゐる

[10:50]

なにかの不具合でうまくいかなかった
ビルドを一回しかしてゐない筈なのに 一日のビルド回數を越えたとのメッセージ
よく分からないが また明日試すしかないか

10/4 [00:26]

Monacaで ShooPinをミクに入れ USBデバッグモードで Braveブラウザから讀みこまうとしたが
なかなかうまく行かず 何とか今 DevToolを開いて Console を確認できてゐる

まづ 縦線のデータを集めやう

画面の1/2程度の長い縦線
a1:

[[(209,399)],[(209,409)],[(209,419)],[(210,429)],[(210,446)],[(210,460)],[(210,474)],[(210,490)],[(210,504)],[(210,515)],[(210,532)],[(210,546)],[(211,560)],[(212,574)],[(213,585)],[(214,600)],[(215,611)],[(215,620)],[(215,628)],[(215,640)],[(215,652)]]

a2:

[[(207,395)],[(208,411)],[(209,430)],[(209,453)],[(208,484)],[(207,510)],[(206,535)],[(206,565)],[(209,593)],[(211,611)],[(215,641)],[(218,656)],[(221,675)]]

a3:

[[(204,385)],[(204,392)],[(203,402)],[(203,412)],[(202,423)],[(202,434)],[(202,445)],[(202,456)],[(202,466)],[(202,479)],[(203,489)],[(202,498)],[(203,509)],[(204,520)],[(203,530)],[(204,542)],[(204,552)],[(205,561)],[(205,567)],[(205,580)],[(205,586)],[(206,598)],[(206,606)],[(207,616)],[(207,625)],[(208,635)],[(210,645)],[(211,655)],[(212,661)],[(213,671)]]

画面の1/4程度の短い縦線

b1:

[[(194,410)],[(194,418)],[(194,427)],[(194,439)],[(193,451)],[(192,464)],[(192,477)],[(192,488)],[(192,497)],[(192,512)]]

b2:

[[(208,543)],[(208,552)],[(208,565)],[(208,579)],[(208,595)],[(209,614)],[(211,631)],[(212,645)],[(213,667)]]

b3:

[[(203,408)],[(203,413)],[(203,418)],[(203,424)],[(203,432)],[(203,441)],[(203,451)],[(204,458)],[(205,465)],[(205,471)],[(206,478)],[(207,486)],[(208,496)],[(209,509)]]

ぱっと見で考へられることは x 座標の範囲が たとへばa3なら202-213なので 大體15pxの範囲に収まってゐるといふことだ

つまり リストのminimum と maximum をとって その差が20より下であり y座標に關しては
minimum と maximum の差が ある一定の範囲にあれば 縦線とみなせるのではないか

横線も同じ理屈で導きだせさうだ

10/4 [10:18]

縦線を認識するやうにコードを實装

Main.hs
>>>

  onEvent ce TouchStart $ \(TouchData a _ _) -> do
    showTouch2 a 
    readIORef state >>= tcStart >>= writeIORef state
  onEvent ce TouchMove $ \ (TouchData a _ _) -> do
    showTouch2 a
    readIORef state >>= writeIORef state . addCoords a
  onEvent ce TouchEnd $ \(TouchData {}) -> do
    readIORef state >>= showCoords >>= touchEvent ci >>= touchIsTrue >>= writeIORef state

Action.hs
+++

touchRead :: CInfo -> [[Pos]] -> [Char]
touchRead ((cW,cH),_) cds = 
  let cH2 = cH/2 
      cH4 = cH/4
      cH8 = cH/8
      tcds = transpose cds
      xys = map unzip tcds
      (maxXs,minXs) = (map (maximum.fst) xys,map (minimum.fst)  xys)
      (maxYs,minYs) = (map (maximum.snd) xys,map (minimum.snd) xys)
      dxs = zipWith (\maxX minX -> fromIntegral $ maxX - minX) maxXs minXs
      dys = zipWith (\maxY minY -> fromIntegral $ maxY - minY) maxYs minYs
      chs = zipWith toch dxs dys
      toch dx dy
       | dx<20 && dy>cH8 && dy<cH2 = '|'
       | otherwise = '?'
   in chs

Loop.hs
+++

touchEvent :: CInfo -> State -> IO State
touchEvent ci st = do
  let tcs = tccs st  
  if null tcs then return st else  print (touchRead ci tcs) >> return (st{tccs=[]})

コンパイルが通つたので ミクで確認する

[10:24]

うまく認識してゐるやうだ
とりあへず 第一関門突破だ

ただ 同時にタップする場合の動作については まだ疑問點がある

完全に同時なら 縦線がふたつ認識されてゐるが

タイミングをずらすと 一つは'?'(認識できない) になる
まだ實驗が必要だ

新たに氣づいたことは 同じ縦線でも
上からタップする場合と下からタップする場合がある
これらは區別した方が 術式のバリエーションが増えるだらう

あと 昨日ゆうとと話して思ひついたこと

どの描画がどの術式に對應するか といふのは ゲームが始まったとき
ランダムで決まるといふのが面白い筈だ

描画の複雑度に應じて それぞれ術式の集合を對應させるが
ある難易度の術式の集合であれば その中の どの術式がどの描画と對應するかは
ランダムに決められる

この實装はまだ先になるだらうが おもしろくなるヴィジョンが廣がつたので
これを完成させるのに より意欲的になれてゐる氣がする



